{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE TupleSections #-}
-- Copyright Â© 2010-2012 Jon Kristensen. See the LICENSE file in the
-- Pontarius distribution for more details.

{-# OPTIONS_HADDOCK hide #-}

{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE OverloadedStrings #-}


module Network.XMPP.Types where

-- import Network.XMPP.Utilities (idGenerator)

import           Control.Applicative((<$>))
import           Control.Exception
import           Control.Monad.IO.Class
import           Control.Monad.State.Strict
import           Control.Monad.Error


import qualified Data.ByteString as BS
import           Data.Conduit
import           Data.List.Split as L
import           Data.String(IsString(..))
import           Data.Text (Text)
import qualified Data.Text as Text
import           Data.Typeable(Typeable)
import           Data.XML.Types

import qualified Network as N

import           System.IO


-- | The string prefix MUST be

data SessionSettings =
  SessionSettings { ssIdPrefix :: String
                  , ssIdGenerator :: IdGenerator
                  , ssStreamLang :: LangTag }


-- =============================================================================
--  STANZA TYPES
-- =============================================================================


-- TODO: Would a Stanza class such as the one below be useful sometimes?
--
-- class Stanza a where
--     stanzaID :: a -> Maybe StanzaID
--     stanzaFrom :: a -> Maybe From
--     stanzaTo :: a -> Maybe To
--     stanzaXMLLang :: a -> Maybe XMLLang


-- |
-- Wraps a string of random characters that, when using an appropriate
-- @IDGenerator@, is guaranteed to be unique for the XMPP session.
-- Stanza identifiers are generated by Pontarius.

data StanzaId = SI !Text deriving (Eq, Ord)

instance Show StanzaId where
  show (SI s) = Text.unpack s

instance Read StanzaId where
  readsPrec _ x = [(SI $ Text.pack x, "")]

instance IsString StanzaId where
  fromString = SI . Text.pack

-- |
-- @From@ is a readability type synonym for @Address@.

-- | Jabber ID (JID) datatype
data JID = JID { localpart :: !(Maybe Text)
               -- ^ Account name
               , domainpart :: !Text
               -- ^ Server adress
               , resourcepart :: !(Maybe Text)
               -- ^ Resource name
               }

instance Show JID where
  show (JID nd dmn res) =
            maybe "" ((++ "@") . Text.unpack) nd ++
            (Text.unpack dmn)               ++
            maybe "" (('/' :) . Text.unpack)   res

parseJID :: [Char] -> [JID]
parseJID jid = do
  (jid', rst) <- case L.splitOn "@" jid of
                      [rest] -> [(JID Nothing, rest)]
                      [nd,rest] -> [(JID (Just (Text.pack nd)), rest)]
                      _ -> []
  case L.splitOn "/" rst of
      [dmn] -> [jid' (Text.pack dmn) Nothing]
      [dmn, rsrc] -> [jid' (Text.pack dmn) (Just (Text.pack rsrc))]
      _ -> []

instance Read JID where
  readsPrec _ x = (,"") <$> parseJID x

-- An Info/Query (IQ) stanza is either of the type "request" ("get" or
-- "set") or "response" ("result" or "error"). The @IQ@ type wraps
-- these two sub-types.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Stanza = IQRequestS     IQRequest
            | IQResultS      IQResult
            | IQErrorS       IQError
            | MessageS       Message
            | MessageErrorS  MessageError
            | PresenceS      Presence
            | PresenceErrorS PresenceError

-- |
-- A "request" Info/Query (IQ) stanza is one with either "get" or
-- "set" as type. They are guaranteed to always contain a payload.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQRequest = IQRequest { iqRequestID      :: StanzaId
                           , iqRequestFrom    :: Maybe JID
                           , iqRequestTo      :: Maybe JID
                           , iqRequestLangTag :: Maybe LangTag
                           , iqRequestType    :: IQRequestType
                           , iqRequestPayload :: Element
                           }
                 deriving (Show)


data IQRequestType = Get | Set deriving (Eq, Ord)

instance Show IQRequestType where
  show Get = "get"
  show Set = "set"

instance Read IQRequestType where
  readsPrec _ "get" = [(Get, "")]
  readsPrec _ "set" = [(Set, "")]
  readsPrec _ _ = []


-- |
-- A "response" Info/Query (IQ) stanza is one with either "result" or
-- "error" as type. We have devided IQ responses into two types.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

type IQResponse = Either IQError IQResult


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQResult = IQResult { iqResultID :: StanzaId
                         , iqResultFrom :: Maybe JID
                         , iqResultTo :: Maybe JID
                         , iqResultLangTag :: Maybe LangTag
                         , iqResultPayload :: Maybe Element }
                deriving (Show)


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQError = IQError { iqErrorID :: StanzaId
                       , iqErrorFrom :: Maybe JID
                       , iqErrorTo :: Maybe JID
                       , iqErrorLangTag :: Maybe LangTag
                       , iqErrorStanzaError :: StanzaError
                       , iqErrorPayload :: Maybe Element -- should this be []?
                       }
               deriving (Show)

-- |
-- A non-error message stanza.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Message = Message { messageID      :: Maybe StanzaId
                       , messageFrom    :: Maybe JID
                       , messageTo      :: Maybe JID
                       , messageLangTag :: Maybe LangTag
                       , messageType    :: MessageType
                       , messageSubject :: Maybe Text
                       , messageThread  :: Maybe Text
                       , messageBody    :: Maybe Text
                       , messagePayload :: [Element]
                       }
               deriving (Show)


-- |
-- An error message stanza.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data MessageError = MessageError { messageErrorID :: Maybe StanzaId
                                 , messageErrorFrom :: Maybe JID
                                 , messageErrorTo :: Maybe JID
                                 , messageErrorLangTag  :: Maybe LangTag
                                 , messageErrorStanzaError :: StanzaError
                                 , messageErrorPayload :: [Element]
                                 }
                    deriving (Show)


-- |
-- @MessageType@ holds XMPP message types as defined in XMPP-IM. The
-- "error" message type is left out as errors are wrapped in
-- @MessageError@.

data MessageType = Chat      | -- ^
                   GroupChat | -- ^
                   Headline  | -- ^
                   Normal      -- ^ The default message type
                   deriving (Eq)


instance Show MessageType where
    show Chat = "chat"
    show GroupChat = "groupchat"
    show Headline = "headline"
    show Normal = "normal"

instance Read MessageType where
  readsPrec _  "chat"      = [( Chat ,"")]
  readsPrec _  "groupchat" = [( GroupChat ,"")]
  readsPrec _  "headline"  = [( Headline ,"")]
  readsPrec _  "normal"    = [( Normal ,"")]
  readsPrec _  _           = [( Normal ,"")]

-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Presence = Presence { presenceID       :: Maybe StanzaId
                         , presenceFrom     :: Maybe JID
                         , presenceTo       :: Maybe JID
                         , presenceLangTag  :: Maybe LangTag
                         , presenceType     :: Maybe PresenceType
                         , presenceShowType :: Maybe ShowType
                         , presenceStatus   :: Maybe Text
                         , presencePriority :: Maybe Int
                         , presencePayload  :: [Element]
                         }
                deriving (Show)


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data PresenceError = PresenceError { presenceErrorID :: Maybe StanzaId
                                   , presenceErrorFrom :: Maybe JID
                                   , presenceErrorTo :: Maybe JID
                                   , presenceErrorLangTag :: Maybe LangTag
                                   , presenceErrorStanzaError :: StanzaError
                                   , presenceErrorPayload :: [Element]
                                   }
                     deriving (Show)

-- |
-- @PresenceType@ holds XMPP presence types. The "error" message type
-- is left out as errors are using @PresenceError@.

data PresenceType = Subscribe    | -- ^ Sender wants to subscribe to presence
                    Subscribed   | -- ^ Sender has approved the subscription
                    Unsubscribe  | -- ^ Sender is unsubscribing from presence
                    Unsubscribed | -- ^ Sender has denied or cancelled a
                                   --   subscription
                    Probe        | -- ^ Sender requests current presence;
                                   --   should only be used by servers
                    Default      |
                    Unavailable deriving (Eq)


instance Show PresenceType where
    show Subscribe    = "subscribe"
    show Subscribed   = "subscribed"
    show Unsubscribe  = "unsubscribe"
    show Unsubscribed = "unsubscribed"
    show Probe        = "probe"
    show Default      = ""
    show Unavailable  = "unavailable"

instance Read PresenceType where
  readsPrec _  ""             = [( Default ,"")]
  readsPrec _  "available"    = [( Default ,"")]
  readsPrec _  "unavailable"  = [( Unavailable ,"")]
  readsPrec _  "subscribe"    = [( Subscribe ,"")]
  readsPrec _  "subscribed"   = [( Subscribed ,"")]
  readsPrec _  "unsubscribe"  = [( Unsubscribe ,"")]
  readsPrec _  "unsubscribed" = [( Unsubscribed ,"")]
  readsPrec _  "probe"        = [( Probe ,"")]
  readsPrec _  _              = []

data ShowType = Available
                | Away
                | FreeChat
                | DND
                | XAway
                deriving Eq

instance Show ShowType where
  show Available = ""
  show Away = "away"
  show FreeChat = "chat"
  show DND = "dnd"
  show XAway = "xa"

instance Read ShowType where
  readsPrec _  ""             = [( Available ,"")]
  readsPrec _  "available"    = [( Available ,"")]
  readsPrec _  "away"         = [( Away ,"")]
  readsPrec _  "chat"         = [( FreeChat ,"")]
  readsPrec _  "dnd"          = [( DND ,"")]
  readsPrec _  "xa"           = [( XAway ,"")]
  readsPrec _  "invisible"    = [( Available ,"")]
  readsPrec _  _              = []


-- |
-- All stanzas (IQ, message, presence) can cause errors, which in the XMPP
-- stream looks like <stanza-kind to='sender' type='error'>. These errors are
-- wrapped in the @StanzaError@ type.

-- TODO: Sender XML is (optional and is) not included.

data StanzaError = StanzaError { stanzaErrorType :: StanzaErrorType
                               , stanzaErrorCondition :: StanzaErrorCondition
                               , stanzaErrorText :: Maybe (Maybe LangTag, Text)
                               , stanzaErrorApplicationSpecificCondition ::
                                 Maybe Element } deriving (Eq, Show)


-- |
-- @StanzaError@s always have one of these types.

data StanzaErrorType = Cancel   | -- ^ Error is unrecoverable - do not retry
                       Continue | -- ^ Conditition was a warning - proceed
                       Modify   | -- ^ Change the data and retry
                       Auth     | -- ^ Provide credentials and retry
                       Wait       -- ^ Error is temporary - wait and retry
                       deriving (Eq)


instance Show StanzaErrorType where
    show Cancel = "cancel"
    show Continue = "continue"
    show Modify = "modify"
    show Auth = "auth"
    show Wait = "wait"

instance Read StanzaErrorType where
  readsPrec _ "auth"     = [( Auth    , "")]
  readsPrec _ "cancel"   = [( Cancel  , "")]
  readsPrec _ "continue" = [( Continue, "")]
  readsPrec _ "modify"   = [( Modify  , "")]
  readsPrec _ "wait"     = [( Wait    , "")]
  readsPrec _ _          = []


-- |
-- Stanza errors are accommodated with one of the error conditions listed below.

data StanzaErrorCondition = BadRequest            | -- ^ Malformed XML
                            Conflict              | -- ^ Resource or session
                                                    --   with name already
                                                    --   exists
                            FeatureNotImplemented |
                            Forbidden             | -- ^ Insufficient
                                                    --   permissions
                            Gone                  | -- ^ Entity can no longer
                                                    --   be contacted at this
                                                    --   address
                            InternalServerError   |
                            ItemNotFound          |
                            JIDMalformed          |
                            NotAcceptable         | -- ^ Does not meet policy
                                                    --   criteria
                            NotAllowed            | -- ^ No entity may perform
                                                    --   this action
                            NotAuthorized         | -- ^ Must provide proper
                                                    --   credentials
                            PaymentRequired       |
                            RecipientUnavailable  | -- ^ Temporarily
                                                    --   unavailable
                            Redirect              | -- ^ Redirecting to other
                                                    --   entity, usually
                                                    --   temporarily
                            RegistrationRequired  |
                            RemoteServerNotFound  |
                            RemoteServerTimeout   |
                            ResourceConstraint    | -- ^ Entity lacks the
                                                    --   necessary system
                                                    --   resources
                            ServiceUnavailable    |
                            SubscriptionRequired  |
                            UndefinedCondition    | -- ^ Application-specific
                                                    --   condition
                            UnexpectedRequest       -- ^ Badly timed request
                            deriving (Eq)


instance Show StanzaErrorCondition where
    show BadRequest = "bad-request"
    show Conflict = "conflict"
    show FeatureNotImplemented = "feature-not-implemented"
    show Forbidden = "forbidden"
    show Gone = "gone"
    show InternalServerError = "internal-server-error"
    show ItemNotFound = "item-not-found"
    show JIDMalformed = "jid-malformed"
    show NotAcceptable = "not-acceptable"
    show NotAllowed = "not-allowed"
    show NotAuthorized = "not-authorized"
    show PaymentRequired = "payment-required"
    show RecipientUnavailable = "recipient-unavailable"
    show Redirect = "redirect"
    show RegistrationRequired = "registration-required"
    show RemoteServerNotFound = "remote-server-not-found"
    show RemoteServerTimeout = "remote-server-timeout"
    show ResourceConstraint = "resource-constraint"
    show ServiceUnavailable = "service-unavailable"
    show SubscriptionRequired = "subscription-required"
    show UndefinedCondition = "undefined-condition"
    show UnexpectedRequest = "unexpected-request"

instance Read StanzaErrorCondition where
    readsPrec _  "bad-request"             = [(BadRequest           , "")]
    readsPrec _  "conflict"                = [(Conflict             , "")]
    readsPrec _  "feature-not-implemented" = [(FeatureNotImplemented, "")]
    readsPrec _  "forbidden"               = [(Forbidden            , "")]
    readsPrec _  "gone"                    = [(Gone                 , "")]
    readsPrec _  "internal-server-error"   = [(InternalServerError  , "")]
    readsPrec _  "item-not-found"          = [(ItemNotFound         , "")]
    readsPrec _  "jid-malformed"           = [(JIDMalformed         , "")]
    readsPrec _  "not-acceptable"          = [(NotAcceptable        , "")]
    readsPrec _  "not-allowed"             = [(NotAllowed           , "")]
    readsPrec _  "not-authorized"          = [(NotAuthorized        , "")]
    readsPrec _  "payment-required"        = [(PaymentRequired      , "")]
    readsPrec _  "recipient-unavailable"   = [(RecipientUnavailable , "")]
    readsPrec _  "redirect"                = [(Redirect             , "")]
    readsPrec _  "registration-required"   = [(RegistrationRequired , "")]
    readsPrec _  "remote-server-not-found" = [(RemoteServerNotFound , "")]
    readsPrec _  "remote-server-timeout"   = [(RemoteServerTimeout  , "")]
    readsPrec _  "resource-constraint"     = [(ResourceConstraint   , "")]
    readsPrec _  "service-unavailable"     = [(ServiceUnavailable   , "")]
    readsPrec _  "subscription-required"   = [(SubscriptionRequired , "")]
    readsPrec _  "unexpected-request"      = [(UnexpectedRequest    , "")]
    readsPrec _  "undefined-condition"     = [(UndefinedCondition   , "")]
    readsPrec _  _                         = [(UndefinedCondition   , "")]

-- =============================================================================
--  OTHER STUFF
-- =============================================================================

data SASLFailure = SASLFailure { saslFailureCondition :: SASLError
                               , saslFailureText :: Maybe Text } -- TODO: XMLLang


data SASLError = -- SASLAborted | -- Client aborted - should not happen
                 SASLAccountDisabled | -- ^ The account has been temporarily
                                       --   disabled
                 SASLCredentialsExpired | -- ^ The authentication failed because
                                          --   the credentials have expired
                 SASLEncryptionRequired | -- ^ The mechanism requested cannot be
                                          --   used the confidentiality and
                                          --   integrity of the underlying
                                          --   stream is protected (typically
                                          --   with TLS)
                 -- SASLIncorrectEncoding | -- The base64 encoding is incorrect
                                            -- - should not happen
                 -- SASLInvalidAuthzid | -- The authzid has an incorrect format,
                                         -- or the initiating entity does not
                                         -- have the appropriate permissions to
                                         -- authorize that ID
                 SASLInvalidMechanism | -- ^ The mechanism is not supported by
                                        --   the receiving entity
                 -- SASLMalformedRequest | -- Invalid syntax - should not happen
                 SASLMechanismTooWeak | -- ^ The receiving entity policy
                                        --   requires a stronger mechanism
                 SASLNotAuthorized (Maybe Text) | -- ^ Invalid credentials
                                                    --   provided, or some
                                                    --   generic authentication
                                                    --   failure has occurred
                 SASLTemporaryAuthFailure -- ^ There receiving entity reported a
                                          --   temporary error condition; the
                                          --   initiating entity is recommended
                                          --   to try again later


-- | Readability type for host name Texts.

-- type HostName = Text -- This is defined in Network as well


-- | Readability type for port number Integers.

type PortNumber = Integer -- We use N(etwork).PortID (PortNumber) internally


-- | Readability type for user name Texts.

type UserName = Text


-- | Readability type for password Texts.

type Password = Text


-- | Readability type for (Address) resource identifier Texts.

type Resource = Text


type StreamID = Text


data ServerAddress = ServerAddress N.HostName N.PortNumber deriving (Eq)

type Timeout = Int

data StreamError = StreamError String
                 | StreamWrongVersion Text
                 | StreamXMLError
                 | StreamUnpickleError String
                 | StreamConnectionError
                 deriving (Show, Eq, Typeable)
instance Exception StreamError
instance Error StreamError where strMsg = StreamError

-- =============================================================================
--  XML TYPES
-- =============================================================================


-- | Wraps a function that MUST generate a stream of unique Ids. The
--   strings MUST be appropriate for use in the stanza id attirubte.
--   For a default implementation, see @idGenerator@.

newtype IdGenerator = IdGenerator (IO Text)


--- other stuff

data Version = Version { majorVersion :: Integer
                       , minorVersion :: Integer } deriving (Eq)


-- Version numbers are displayed as "<major>.<minor>".

instance Show Version where
    show (Version major minor) = (show major) ++ "." ++ (show minor)


-- If the major version numbers are not equal, compare them. Otherwise, compare
-- the minor version numbers.

instance Ord Version where
    compare (Version amajor aminor) (Version bmajor bminor)
        | amajor /= bmajor = compare amajor bmajor
        | otherwise = compare aminor bminor


data LangTag = LangTag { primaryTag :: Text
                       , subtags :: [Text] }
                        deriving (Eq) -- TODO: remove


-- Displays the language tag in the form of "en-US".

instance Show LangTag where
    show (LangTag p []) = Text.unpack p
    show (LangTag p s) = Text.unpack . Text.concat
                           $ [p, "-", Text.intercalate "-" s] -- TODO: clean up

parseLangTag :: Text -> [LangTag]
parseLangTag txt = case Text.splitOn "-" txt of
  [] -> []
  prim: subs -> [LangTag prim subs]

instance Read LangTag where
  readsPrec _ txt = (,"") <$> (parseLangTag $ Text.pack txt)

-- Two language tags are considered equal of they contain the same tags (case-insensitive).

-- TODO: port

-- instance Eq LangTag where
--   (LangTag ap as) == (LangTag bp bs)
--         | length as == length bs && map toLower ap == map toLower bp =
--           all (\ (a, b) -> map toLower a == map toLower b) $ zip as bs
--         | otherwise = False



data ServerFeatures = SF
  { stls  :: Maybe Bool
  , saslMechanisms :: [Text.Text]
  , other :: [Element]
  } deriving Show

data XMPPConState = XMPPConState
               { sConSrc    :: Source IO Event
               , sRawSrc    :: Source IO BS.ByteString
               , sConPushBS :: BS.ByteString -> IO ()
               , sConHandle :: Maybe Handle
               , sFeatures  :: ServerFeatures
               , sHaveTLS   :: Bool
               , sHostname  :: Maybe Text
               , sUsername  :: Maybe Text
               , sResource  :: Maybe Text
               }

-- |
-- The XMPP monad transformer. Contains internal state in order to
-- work with Pontarius. Pontarius clients needs to operate in this
-- context.

newtype XMPPT m a = XMPPT { runXMPPT :: StateT XMPPConState m a } deriving (Monad, MonadIO)

type XMPPConMonad a = StateT XMPPConState IO a

-- Make XMPPT derive the Monad and MonadIO instances.

deriving instance (Monad m, MonadIO m) => MonadState (XMPPConState) (XMPPT m)


-- We need a channel because multiple threads needs to append events,
-- and we need to wait for events when there are none.
