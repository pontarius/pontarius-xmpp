{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE TupleSections #-}
-- Copyright Â© 2010-2012 Jon Kristensen. See the LICENSE file in the
-- Pontarius distribution for more details.

{-# OPTIONS_HADDOCK hide #-}

{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE OverloadedStrings #-}


module Network.XMPP.Types
    ( IQError(..)
    , IQRequest(..)
    , IQRequestType(..)
    , IQResponse(..)
    , IQResult(..)
    , IdGenerator(..)
    , LangTag (..)
    , Message(..)
    , MessageError(..)
    , MessageType(..)
    , Presence(..)
    , PresenceError(..)
    , PresenceType(..)
    , SASLError(..)
    , SASLFailure(..)
    , ServerAddress(..)
    , ServerFeatures(..)
    , ShowType(..)
    , Stanza(..)
    , StanzaError(..)
    , StanzaErrorCondition(..)
    , StanzaErrorType(..)
    , StanzaId(..)
    , StreamError(..)
    , Version(..)
    , XMPPConMonad(..)
    , XMPPConState(..)
    , XMPPT(..)
    , parseLangTag
    , module Network.XMPP.JID
    )
       where

-- import Network.XMPP.Utilities (idGenerator)

import           Control.Applicative((<$>))
import           Control.Exception
import           Control.Monad.IO.Class
import           Control.Monad.State.Strict
import           Control.Monad.Error


import qualified Data.ByteString as BS
import           Data.Conduit
import           Data.List.Split as L
import           Data.String(IsString(..))
import           Data.Text (Text)
import qualified Data.Text as Text
import           Data.Typeable(Typeable)
import           Data.XML.Types

import qualified Network as N

import           Network.XMPP.JID

import           System.IO


-- | The string prefix MUST be

data SessionSettings =
  SessionSettings { ssIdPrefix :: String
                  , ssIdGenerator :: IdGenerator
                  , ssStreamLang :: LangTag }


-- =============================================================================
--  STANZA TYPES
-- =============================================================================


-- TODO: Would a Stanza class such as the one below be useful sometimes?
--
-- class Stanza a where
--     stanzaID :: a -> Maybe StanzaID
--     stanzaFrom :: a -> Maybe From
--     stanzaTo :: a -> Maybe To
--     stanzaXMLLang :: a -> Maybe XMLLang


-- |
-- Wraps a string of random characters that, when using an appropriate
-- @IDGenerator@, is guaranteed to be unique for the XMPP session.
-- Stanza identifiers are generated by Pontarius.

data StanzaId = SI !Text deriving (Eq, Ord)

instance Show StanzaId where
  show (SI s) = Text.unpack s

instance Read StanzaId where
  readsPrec _ x = [(SI $ Text.pack x, "")]

instance IsString StanzaId where
  fromString = SI . Text.pack

-- An Info/Query (IQ) stanza is either of the type "request" ("get" or
-- "set") or "response" ("result" or "error"). The @IQ@ type wraps
-- these two sub-types.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Stanza = IQRequestS     IQRequest
            | IQResultS      IQResult
            | IQErrorS       IQError
            | MessageS       Message
            | MessageErrorS  MessageError
            | PresenceS      Presence
            | PresenceErrorS PresenceError
              deriving Show

-- |
-- A "request" Info/Query (IQ) stanza is one with either "get" or
-- "set" as type. They are guaranteed to always contain a payload.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQRequest = IQRequest { iqRequestID      :: StanzaId
                           , iqRequestFrom    :: Maybe JID
                           , iqRequestTo      :: Maybe JID
                           , iqRequestLangTag :: Maybe LangTag
                           , iqRequestType    :: IQRequestType
                           , iqRequestPayload :: Element
                           }
                 deriving (Show)


data IQRequestType = Get | Set deriving (Eq, Ord)

instance Show IQRequestType where
  show Get = "get"
  show Set = "set"

instance Read IQRequestType where
  readsPrec _ "get" = [(Get, "")]
  readsPrec _ "set" = [(Set, "")]
  readsPrec _ _ = []


-- |
-- A "response" Info/Query (IQ) stanza is one with either "result" or
-- "error" as type. We have devided IQ responses into two types.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

type IQResponse = Either IQError IQResult


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQResult = IQResult { iqResultID :: StanzaId
                         , iqResultFrom :: Maybe JID
                         , iqResultTo :: Maybe JID
                         , iqResultLangTag :: Maybe LangTag
                         , iqResultPayload :: Maybe Element }
                deriving (Show)


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data IQError = IQError { iqErrorID :: StanzaId
                       , iqErrorFrom :: Maybe JID
                       , iqErrorTo :: Maybe JID
                       , iqErrorLangTag :: Maybe LangTag
                       , iqErrorStanzaError :: StanzaError
                       , iqErrorPayload :: Maybe Element -- should this be []?
                       }
               deriving (Show)

-- |
-- A non-error message stanza.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Message = Message { messageID      :: Maybe StanzaId
                       , messageFrom    :: Maybe JID
                       , messageTo      :: Maybe JID
                       , messageLangTag :: Maybe LangTag
                       , messageType    :: MessageType
                       , messageSubject :: Maybe Text
                       , messageThread  :: Maybe Text
                       , messageBody    :: Maybe Text
                       , messagePayload :: [Element]
                       }
               deriving (Show)


-- |
-- An error message stanza.
--
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data MessageError = MessageError { messageErrorID :: Maybe StanzaId
                                 , messageErrorFrom :: Maybe JID
                                 , messageErrorTo :: Maybe JID
                                 , messageErrorLangTag  :: Maybe LangTag
                                 , messageErrorStanzaError :: StanzaError
                                 , messageErrorPayload :: [Element]
                                 }
                    deriving (Show)


-- |
-- @MessageType@ holds XMPP message types as defined in XMPP-IM. The
-- "error" message type is left out as errors are wrapped in
-- @MessageError@.

data MessageType = Chat      | -- ^
                   GroupChat | -- ^
                   Headline  | -- ^
                   Normal      -- ^ The default message type
                   deriving (Eq)


instance Show MessageType where
    show Chat = "chat"
    show GroupChat = "groupchat"
    show Headline = "headline"
    show Normal = "normal"

instance Read MessageType where
  readsPrec _  "chat"      = [( Chat ,"")]
  readsPrec _  "groupchat" = [( GroupChat ,"")]
  readsPrec _  "headline"  = [( Headline ,"")]
  readsPrec _  "normal"    = [( Normal ,"")]
  readsPrec _  _           = [( Normal ,"")]

-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data Presence = Presence { presenceID       :: Maybe StanzaId
                         , presenceFrom     :: Maybe JID
                         , presenceTo       :: Maybe JID
                         , presenceLangTag  :: Maybe LangTag
                         , presenceType     :: Maybe PresenceType
                         , presenceShowType :: Maybe ShowType
                         , presenceStatus   :: Maybe Text
                         , presencePriority :: Maybe Int
                         , presencePayload  :: [Element]
                         }
                deriving (Show)


-- |
-- Objects of this type cannot be generated by Pontarius applications,
-- but are only created internally.

data PresenceError = PresenceError { presenceErrorID :: Maybe StanzaId
                                   , presenceErrorFrom :: Maybe JID
                                   , presenceErrorTo :: Maybe JID
                                   , presenceErrorLangTag :: Maybe LangTag
                                   , presenceErrorStanzaError :: StanzaError
                                   , presenceErrorPayload :: [Element]
                                   }
                     deriving (Show)

-- |
-- @PresenceType@ holds XMPP presence types. The "error" message type
-- is left out as errors are using @PresenceError@.

data PresenceType = Subscribe    | -- ^ Sender wants to subscribe to presence
                    Subscribed   | -- ^ Sender has approved the subscription
                    Unsubscribe  | -- ^ Sender is unsubscribing from presence
                    Unsubscribed | -- ^ Sender has denied or cancelled a
                                   --   subscription
                    Probe        | -- ^ Sender requests current presence;
                                   --   should only be used by servers
                    Default      |
                    Unavailable deriving (Eq)


instance Show PresenceType where
    show Subscribe    = "subscribe"
    show Subscribed   = "subscribed"
    show Unsubscribe  = "unsubscribe"
    show Unsubscribed = "unsubscribed"
    show Probe        = "probe"
    show Default      = ""
    show Unavailable  = "unavailable"

instance Read PresenceType where
  readsPrec _  ""             = [( Default ,"")]
  readsPrec _  "available"    = [( Default ,"")]
  readsPrec _  "unavailable"  = [( Unavailable ,"")]
  readsPrec _  "subscribe"    = [( Subscribe ,"")]
  readsPrec _  "subscribed"   = [( Subscribed ,"")]
  readsPrec _  "unsubscribe"  = [( Unsubscribe ,"")]
  readsPrec _  "unsubscribed" = [( Unsubscribed ,"")]
  readsPrec _  "probe"        = [( Probe ,"")]
  readsPrec _  _              = []

data ShowType = Available
                | Away
                | FreeChat
                | DND
                | XAway
                deriving Eq

instance Show ShowType where
  show Available = ""
  show Away = "away"
  show FreeChat = "chat"
  show DND = "dnd"
  show XAway = "xa"

instance Read ShowType where
  readsPrec _  ""             = [( Available ,"")]
  readsPrec _  "available"    = [( Available ,"")]
  readsPrec _  "away"         = [( Away ,"")]
  readsPrec _  "chat"         = [( FreeChat ,"")]
  readsPrec _  "dnd"          = [( DND ,"")]
  readsPrec _  "xa"           = [( XAway ,"")]
  readsPrec _  "invisible"    = [( Available ,"")]
  readsPrec _  _              = []


-- |
-- All stanzas (IQ, message, presence) can cause errors, which in the XMPP
-- stream looks like <stanza-kind to='sender' type='error'>. These errors are
-- wrapped in the @StanzaError@ type.

-- TODO: Sender XML is (optional and is) not included.

data StanzaError = StanzaError { stanzaErrorType :: StanzaErrorType
                               , stanzaErrorCondition :: StanzaErrorCondition
                               , stanzaErrorText :: Maybe (Maybe LangTag, Text)
                               , stanzaErrorApplicationSpecificCondition ::
                                 Maybe Element } deriving (Eq, Show)


-- |
-- @StanzaError@s always have one of these types.

data StanzaErrorType = Cancel   | -- ^ Error is unrecoverable - do not retry
                       Continue | -- ^ Conditition was a warning - proceed
                       Modify   | -- ^ Change the data and retry
                       Auth     | -- ^ Provide credentials and retry
                       Wait       -- ^ Error is temporary - wait and retry
                       deriving (Eq)


instance Show StanzaErrorType where
    show Cancel = "cancel"
    show Continue = "continue"
    show Modify = "modify"
    show Auth = "auth"
    show Wait = "wait"

instance Read StanzaErrorType where
  readsPrec _ "auth"     = [( Auth    , "")]
  readsPrec _ "cancel"   = [( Cancel  , "")]
  readsPrec _ "continue" = [( Continue, "")]
  readsPrec _ "modify"   = [( Modify  , "")]
  readsPrec _ "wait"     = [( Wait    , "")]
  readsPrec _ _          = []


-- |
-- Stanza errors are accommodated with one of the error conditions listed below.

data StanzaErrorCondition = BadRequest            | -- ^ Malformed XML
                            Conflict              | -- ^ Resource or session
                                                    --   with name already
                                                    --   exists
                            FeatureNotImplemented |
                            Forbidden             | -- ^ Insufficient
                                                    --   permissions
                            Gone                  | -- ^ Entity can no longer
                                                    --   be contacted at this
                                                    --   address
                            InternalServerError   |
                            ItemNotFound          |
                            JIDMalformed          |
                            NotAcceptable         | -- ^ Does not meet policy
                                                    --   criteria
                            NotAllowed            | -- ^ No entity may perform
                                                    --   this action
                            NotAuthorized         | -- ^ Must provide proper
                                                    --   credentials
                            PaymentRequired       |
                            RecipientUnavailable  | -- ^ Temporarily
                                                    --   unavailable
                            Redirect              | -- ^ Redirecting to other
                                                    --   entity, usually
                                                    --   temporarily
                            RegistrationRequired  |
                            RemoteServerNotFound  |
                            RemoteServerTimeout   |
                            ResourceConstraint    | -- ^ Entity lacks the
                                                    --   necessary system
                                                    --   resources
                            ServiceUnavailable    |
                            SubscriptionRequired  |
                            UndefinedCondition    | -- ^ Application-specific
                                                    --   condition
                            UnexpectedRequest       -- ^ Badly timed request
                            deriving (Eq)


instance Show StanzaErrorCondition where
    show BadRequest = "bad-request"
    show Conflict = "conflict"
    show FeatureNotImplemented = "feature-not-implemented"
    show Forbidden = "forbidden"
    show Gone = "gone"
    show InternalServerError = "internal-server-error"
    show ItemNotFound = "item-not-found"
    show JIDMalformed = "jid-malformed"
    show NotAcceptable = "not-acceptable"
    show NotAllowed = "not-allowed"
    show NotAuthorized = "not-authorized"
    show PaymentRequired = "payment-required"
    show RecipientUnavailable = "recipient-unavailable"
    show Redirect = "redirect"
    show RegistrationRequired = "registration-required"
    show RemoteServerNotFound = "remote-server-not-found"
    show RemoteServerTimeout = "remote-server-timeout"
    show ResourceConstraint = "resource-constraint"
    show ServiceUnavailable = "service-unavailable"
    show SubscriptionRequired = "subscription-required"
    show UndefinedCondition = "undefined-condition"
    show UnexpectedRequest = "unexpected-request"

instance Read StanzaErrorCondition where
    readsPrec _  "bad-request"             = [(BadRequest           , "")]
    readsPrec _  "conflict"                = [(Conflict             , "")]
    readsPrec _  "feature-not-implemented" = [(FeatureNotImplemented, "")]
    readsPrec _  "forbidden"               = [(Forbidden            , "")]
    readsPrec _  "gone"                    = [(Gone                 , "")]
    readsPrec _  "internal-server-error"   = [(InternalServerError  , "")]
    readsPrec _  "item-not-found"          = [(ItemNotFound         , "")]
    readsPrec _  "jid-malformed"           = [(JIDMalformed         , "")]
    readsPrec _  "not-acceptable"          = [(NotAcceptable        , "")]
    readsPrec _  "not-allowed"             = [(NotAllowed           , "")]
    readsPrec _  "not-authorized"          = [(NotAuthorized        , "")]
    readsPrec _  "payment-required"        = [(PaymentRequired      , "")]
    readsPrec _  "recipient-unavailable"   = [(RecipientUnavailable , "")]
    readsPrec _  "redirect"                = [(Redirect             , "")]
    readsPrec _  "registration-required"   = [(RegistrationRequired , "")]
    readsPrec _  "remote-server-not-found" = [(RemoteServerNotFound , "")]
    readsPrec _  "remote-server-timeout"   = [(RemoteServerTimeout  , "")]
    readsPrec _  "resource-constraint"     = [(ResourceConstraint   , "")]
    readsPrec _  "service-unavailable"     = [(ServiceUnavailable   , "")]
    readsPrec _  "subscription-required"   = [(SubscriptionRequired , "")]
    readsPrec _  "unexpected-request"      = [(UnexpectedRequest    , "")]
    readsPrec _  "undefined-condition"     = [(UndefinedCondition   , "")]
    readsPrec _  _                         = [(UndefinedCondition   , "")]

-- =============================================================================
--  OTHER STUFF
-- =============================================================================

data SASLFailure = SASLFailure { saslFailureCondition :: SASLError
                               , saslFailureText :: Maybe ( Maybe LangTag
                                                          , Text
                                                          )
                               } deriving Show


data SASLError = SASLAborted              -- ^ Client aborted
               | SASLAccountDisabled      -- ^ The account has been temporarily
                                          --   disabled
               | SASLCredentialsExpired   -- ^ The authentication failed because
                                          --   the credentials have expired
               | SASLEncryptionRequired   -- ^ The mechanism requested cannot be
                                          --   used the confidentiality and
                                          --   integrity of the underlying
                                          --   stream is protected (typically
                                          --   with TLS)
               | SASLIncorrectEncoding    -- ^ The base64 encoding is incorrect
               | SASLInvalidAuthzid       -- ^ The authzid has an incorrect
                                          -- format or the initiating entity does
                                          -- not have the appropriate permissions
                                          -- to authorize that ID
               | SASLInvalidMechanism     -- ^ The mechanism is not supported by
                                          --   the receiving entity
               | SASLMalformedRequest     -- ^ Invalid syntax
               | SASLMechanismTooWeak     -- ^ The receiving entity policy
                                          --   requires a stronger mechanism
               | SASLNotAuthorized        -- ^ Invalid credentials
                                          --   provided, or some
                                          --   generic authentication
                                          --   failure has occurred
               | SASLTemporaryAuthFailure -- ^ There receiving entity reported a
                                          --   temporary error condition; the
                                          --   initiating entity is recommended
                                          --   to try again later

instance Show SASLError where
    show SASLAborted               = "aborted"
    show SASLAccountDisabled       = "account-disabled"
    show SASLCredentialsExpired    = "credentials-expired"
    show SASLEncryptionRequired    = "encryption-required"
    show SASLIncorrectEncoding     = "incorrect-encoding"
    show SASLInvalidAuthzid        = "invalid-authzid"
    show SASLInvalidMechanism      = "invalid-mechanism"
    show SASLMalformedRequest      = "malformed-request"
    show SASLMechanismTooWeak      = "mechanism-too-weak"
    show SASLNotAuthorized         = "not-authorized"
    show SASLTemporaryAuthFailure  = "temporary-auth-failure"

instance Read SASLError where
    readsPrec _ "aborted"                = [(SASLAborted              , "")]
    readsPrec _ "account-disabled"       = [(SASLAccountDisabled      , "")]
    readsPrec _ "credentials-expired"    = [(SASLCredentialsExpired   , "")]
    readsPrec _ "encryption-required"    = [(SASLEncryptionRequired   , "")]
    readsPrec _ "incorrect-encoding"     = [(SASLIncorrectEncoding    , "")]
    readsPrec _ "invalid-authzid"        = [(SASLInvalidAuthzid       , "")]
    readsPrec _ "invalid-mechanism"      = [(SASLInvalidMechanism     , "")]
    readsPrec _ "malformed-request"      = [(SASLMalformedRequest     , "")]
    readsPrec _ "mechanism-too-weak"     = [(SASLMechanismTooWeak     , "")]
    readsPrec _ "not-authorized"         = [(SASLNotAuthorized        , "")]
    readsPrec _ "temporary-auth-failure" = [(SASLTemporaryAuthFailure , "")]

-- | Readability type for host name Texts.

-- type HostName = Text -- This is defined in Network as well


-- | Readability type for port number Integers.

type PortNumber = Integer -- We use N(etwork).PortID (PortNumber) internally


-- | Readability type for user name Texts.

type UserName = Text


-- | Readability type for password Texts.

type Password = Text


-- | Readability type for (Address) resource identifier Texts.

type Resource = Text


type StreamID = Text


data ServerAddress = ServerAddress N.HostName N.PortNumber deriving (Eq)

type Timeout = Int

data StreamError = StreamError String
                 | StreamWrongVersion Text
                 | StreamXMLError
                 | StreamUnpickleError String
                 | StreamConnectionError
                 deriving (Show, Eq, Typeable)
instance Exception StreamError
instance Error StreamError where strMsg = StreamError

-- =============================================================================
--  XML TYPES
-- =============================================================================


-- | Wraps a function that MUST generate a stream of unique Ids. The
--   strings MUST be appropriate for use in the stanza id attirubte.
--   For a default implementation, see @idGenerator@.

newtype IdGenerator = IdGenerator (IO Text)


--- other stuff

data Version = Version { majorVersion :: Integer
                       , minorVersion :: Integer } deriving (Eq)


-- Version numbers are displayed as "<major>.<minor>".

instance Show Version where
    show (Version major minor) = (show major) ++ "." ++ (show minor)


-- If the major version numbers are not equal, compare them. Otherwise, compare
-- the minor version numbers.

instance Ord Version where
    compare (Version amajor aminor) (Version bmajor bminor)
        | amajor /= bmajor = compare amajor bmajor
        | otherwise = compare aminor bminor


data LangTag = LangTag { primaryTag :: Text
                       , subtags :: [Text] }
                        deriving (Eq) -- TODO: remove


-- Displays the language tag in the form of "en-US".

instance Show LangTag where
    show (LangTag p []) = Text.unpack p
    show (LangTag p s) = Text.unpack . Text.concat
                           $ [p, "-", Text.intercalate "-" s] -- TODO: clean up

parseLangTag :: Text -> [LangTag]
parseLangTag txt = case Text.splitOn "-" txt of
  [] -> []
  prim: subs -> [LangTag prim subs]

instance Read LangTag where
  readsPrec _ txt = (,"") <$> (parseLangTag $ Text.pack txt)

-- Two language tags are considered equal of they contain the same tags (case-insensitive).

-- TODO: port

-- instance Eq LangTag where
--   (LangTag ap as) == (LangTag bp bs)
--         | length as == length bs && map toLower ap == map toLower bp =
--           all (\ (a, b) -> map toLower a == map toLower b) $ zip as bs
--         | otherwise = False



data ServerFeatures = SF
  { stls  :: Maybe Bool
  , saslMechanisms :: [Text.Text]
  , other :: [Element]
  } deriving Show

data XMPPConState = XMPPConState
               { sConSrc    :: Source IO Event
               , sRawSrc    :: Source IO BS.ByteString
               , sConPushBS :: BS.ByteString -> IO ()
               , sConHandle :: Maybe Handle
               , sFeatures  :: ServerFeatures
               , sHaveTLS   :: Bool
               , sHostname  :: Maybe Text
               , sUsername  :: Maybe Text
               , sResource  :: Maybe Text
               , sCloseConnection :: IO ()
               }

-- |
-- The XMPP monad transformer. Contains internal state in order to
-- work with Pontarius. Pontarius clients needs to operate in this
-- context.

newtype XMPPT m a = XMPPT { runXMPPT :: StateT XMPPConState m a } deriving (Monad, MonadIO)

type XMPPConMonad a = StateT XMPPConState IO a

-- Make XMPPT derive the Monad and MonadIO instances.

deriving instance (Monad m, MonadIO m) => MonadState (XMPPConState) (XMPPT m)


-- We need a channel because multiple threads needs to append events,
-- and we need to wait for events when there are none.
